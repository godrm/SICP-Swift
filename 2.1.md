### 이전 목차

[2장 데이터로 요약하는 방식](https://github.com/godrm/SICP-Swift/blob/master/Chapter2.md)

## <a name="head2.1"></a> 2.1 데이터 내용 감추고 요약하기 Introduction to Data Abstraction

1.1.8절에서 프로시저가 상위 프로시저 일부라면, 상위 프로시저가 일하는 절차를 요약해서 하위 프로시저 속에 감추는 것으로 볼 수 있다는 것을 알았다. 다른 의미로 보면, 프로시저 내용을 모르더라도 같은 동작을 하는 다른 프로시저가 있다면 부품처럼 맞바꿔 사용할 수 있다는 의미다. 요약한 프로시저를 사용하기 때문에, 프로시저에 절차를 표현해서 정의하는 하위 부분과 사용하는 상위 부분을 나누어 생각할 수 있다. 그 경계를 `요약의 경계`로 구분할 수 있다. 데이터에서 이와 같은 개념이 `데이터 요약`이다. 데이터도 마찬가지로 묶음 데이터를 만드는 부분과 사용하는 부분으로 구분할 수 있다. 

데이터 요약 관점에서 프로그램을 작성할 때 복잡한 데이터는 `요약한 데이터`로 연산할 수 있어야 한다. 데이터에 조건을 달지 않아야 하고, 데이터를 사용하는 프로그램에도 드러내지 않아야 한다. 데이터를 만드는 부분과 사용하는 부분을 이어주는 인터페이스를 선택자selector와 구성자constructor 라고 부른다. 유리수 프로시저를 설계하면서 설명해보자.

### 2.1.1 연습 : 유리수를 위한 산술 연산

분자와 분모로 유리수를 짜맞추는 연산 constructor와 유리수에서 분모와 분자를 골라내는 연산 selector를 다음 프로시저로 정의하자.

`make_rational(n, d)` 분자가 `n`이고 분모가 `d`인 유리수를 내놓는다.
`number(x)` 유리수 `x`의 분자를 내놓는다.
`denominator(x)` 유리수 `x`의 분모를 내놓는다.

여기 세 프로시저는 어떻게 정의했는지 몰라도 이 프로시저만 있으면, 아래와 같은 관계로 유리수 연산들을 만들 수 있다. 

```swift
func add_rational(x: Rational, y: Rational) -> Rational {
    return make_rational(n: number(r: x) * denominator(r: y) + number(r: y) * denominator(r: x), 
                         d: denominator(r: x) * denominator(r: y))
}

func sub_rational(x: Rational, y: Rational) -> Rational {
    return make_rational(n: number(r: x) * denominator(r: y) - number(r: y) * denominator(r: x), 
                         d: denominator(r: x) * denominator(r: y))
}

func mul_rational(x: Rational, y: Rational) -> Rational {
    return make_rational(n: number(r: x) * number(r: y) , 
                         d: denominator(r: x) * denominator(r: y))
}

func div_rational(x: Rational, y: Rational) -> Rational {
    return make_rational(n: number(r: x) * denominator(r: y), 
                         d: denominator(r: x) * number(r: y))
}

func equal_rational(x: Rational, y: Rational) -> Bool {
    return number(r: x) * denominator(r: y) == number(r: y) * denominator(r: x)
}```

#### 쌍Pair과 튜플Tuple

스킴Scheme에서는 데이터를 짝을 맞춰서 표현하기 위해서 쌍Pair이라는 데이터 구조를 사용한다. 스위프트에서 Pair 대신에 Tuple을 사용한다. 튜플에서 내부 값을 골라낼 때는 `.0`, `.1` 등을 사용한다.  

```swift
let x = (1, 2)

x.0 
> 1

x.1
> 2
```

튜플에는 이름을 붙일 수도 있고, 연산하기 위해 전달할 수도 있다. 다른 튜플을 새로운 튜플로 묶을 수도 있다.  

```swift
let x = (1, 2)
let y = (3, 4)
let z = (x, y)

z.0.0
> 3
z.1.0
> 1
```

튜플은 엄밀히 말해서 쌍이 아니라 여러 값을 묶을 수도 있다. 

```swift
let t = (1, 2, 3)
let q = (9, 10, 11, 12)
```

복잡한 데이터 구조를 만들 때 튜플을 확장하면 리스트 구조를 갖춘 데이터를 만들 수 있다. 

### 유리수 만들기

튜플을 활용해서 위에서 만든 유리수 시스템을 완성해보자. 

```swift
typealias Rational = (Int, Int)

func make_rational(n: Int, d: Int) -> Rational {
    return Rational(number: n, denominator: d)
}

func number(r: Rational) -> Int {
    return r.0
}

func denominator(r: Rational) -> Int {
    return r.1
}
```

이렇게 Rational 이란 튜플을 새로운 타입 이름으로 별명typealias를 지정할 수 있다.
스위프트 튜플에서는 `r.0` 또는 `r.1` 순서 대신에 이름을 붙일 수도 있다. 

```swift
typealias Rational = (number:Int, denominator:Int)

func make_rational(n: Int, d: Int) -> Rational {
    return Rational(number: n, denominator: d)
}

func number(r: Rational) -> Int {
    return r.number
}

func denominator(r: Rational) -> Int {
    return r.denominator
}
```

이제 계산 결과를 나타낼 때 `분자 / 분모` 차례로 유리수를 찍을 수도 있다. 

```swift
func print_rational(x: Rational) {
    print("\(number(r:x)) / \(denominator(r:x))")
}
```

모든 시스템 프로시저를 만들었으니까, 제대로 돌아가는지 살펴보자.

```swift
let one_half = make_rational(n: 1, d: 2)
print_rational(x: one_half)

let one_third = make_rational(n: 1, d: 3)
print_rational(x: add_rational(x: one_half, y: one_third))

print_rational(x: mul_rational(x: one_half, y: one_third))

print_rational(x: add_rational(x: one_third, y: one_third))
```

마지막 계산 결과는 `6/9`가 출력되고 기약분수가 아니다. 이 문제를 해결하려면 make_rational()을 고쳐야 한다. 1.2.5절에서 만든 gcd 프로시저를 써서, 분자와 분모를 최대공약수로 나누어서 기약분수로 만든다. 

```swift
func make_rational(n: Int, d: Int) -> Rational {
    let g = gcd(a: n, b: d)
    return Rational(number: n / g, denominator: d / g)
}
```

이제 `print_rational(x: add_rational(x: one_third, y: one_third))`를 실행하면 `2/3` 값이 출력된다. 다른 연산 프로시저는 고치지 않았고 단지 make_rational()만 고쳤다.

#### 연습문제 2.1

```swift
func sign(_ x: Int) -> Int {
    if x < 0 {
        return -1
    }
    else if x > 0 {
        return 1
    }
    return 0
}

func make_rational(n: Int, d: Int) -> Rational {
    let g = gcd(a: n, b: d)
    return Rational(number: sign(n) * sign(d) * abs(n / g), denominator: abs(d / g))
}
```

## 2.1.2 요약의 경계 abstraction barrier
