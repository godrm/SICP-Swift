
### 이전 목차

[1장 프로시저로 요약하는 방식](https://github.com/godrm/SICP-Swift/blob/master/Chapter1.md)

[이전 1.1 The Elements of Programming](https://github.com/godrm/SICP-Swift/blob/master/1.1.md)

[이전 1.2 Procedures and the Processes They Generate](https://github.com/godrm/SICP-Swift/blob/master/1.2.md)

## <a name="head1.3"></a> 1.3 차수가 높은 고차 프로시저(함수)로 요약하는 방식 Formulating Abstractions with Higher-Order procedure

```swift
func cube(x: Int) -> Int {
    return x * x * x
}

func cube(x: Double) -> Double {
    return x * x * x
}
```

이 프로시저는 정수와 실수 모두 세제곱을 계산하도록 구현한 것이다. 워낙 간단한 계산이기 때문에 이렇게 선언한 것을 사용하지 않고, `3 * 3 * 3` 또는 `x * x * x`처럼 기본 연산으로 풀어서 쓸 수도 있다. 같은 세제곱을 계산하더라도 언어로 세제곱이라는 계산(또는 연산)을 나타내는 단어를 선언하는 게 좋다. 프로그래밍 언어는 되풀이되는 계산을 간추려서 대표하는 의미있는 이름으로 붙이는 게 중요하다. 프로시저를 선언하는 것도 그 중에 한 가지 방법이다. 

단순한 계산을 하는 경우만 봐도 프로시저가 매개변수로 숫자만 받을 수 있다면, 새로운 표현으로 추상화해서 정의하는 능력은 제한될 수 밖에 없다. 이런저런 프로그램에서 여러 프로시저를 사용하는 방식이 비슷한 경우를 종종 볼 수 있다. 그래서 반복하는 계산 방식을 간추리려면, 숫자는 물론 다른 프로시저를 인자로 받거나 결과로 되돌려 주는 프로시저를 만들 수 있어야 한다. 이처럼 프로시저를 데이터처럼 사용하는 프로시저를 고차 프로시저( 또는 고차 함수) high-order function 라고 한다. 

### 1.3.1 프로시저를 인자로 받는 프로시저

다음 두 함수는 각각 a부터 b까지 정수의 합을 구하는 프로시저와 정해진 넓이 속 정수를 세제곱 하는 프로시저다. 

```swift
func sum_intergers(a: Int, b: Int) -> Int {
    if a > b {
        return 0
    }
    else {
        return a + sum_intergers(a + 1, b)
    }
}

func sum_cubes(a: Int, b: Int) -> Int {
    if a > b {
        return 0
    }
    else {
        return a + sum_cubes(a + 1, b)
    }
}
```

세 번째 프로시저는 다음 수열에서 모든 마디를 더하는 프로시저다. 

```swift
func pi_sum(a: Double, b: Double) -> Double {
    if a > b {
        return 0
    }
    else {
        return 1.0 / (a * (a + 2)) + pi_sum(a + 4, b)
    }
}
```

여기까지 프로시저를 읽고나면 세 프로시자가 같은 계산 방법을 사용하고 있다는 것을 눈치챌 수 있다. 프로시저의 이름, 마디 값 a를 받아서 계산하는 함수, a 다음 값을 계산하는 함수만 다를 뿐이다. 따라서 다음 프로시저 틀에서 name, term, next 빈 칸만 채우면 세 가지 모든 프로시저를 표현할 수 있다. 

```swift
func name(a: Double, b: Double) -> Double {
    if a > b {
        return 0
    }
    else {
        return term(a) + name(next(a), b)
    }
}
```

이렇게 여러 프로시저에 같은 계산 방법을 적용할 수 있다는 것은 이를 간추릴 때 사용할 수 있는 프로시저가 나올 수 있다는 의미다. 수학자들은 아주 오래 전부터 수열 마디를 더하는 일을 같은 계산 방법으로 표현할 수 있다는 것을 알았다. 그렇게 `시그마 표현식`을 만들었다. 

name, term, next 빈 자리를 인자 이름오 바꿔서 표현해보면 다음과 같다. 

```swift
func sum(_ term: (Double) -> Double, _ a: Double, _ next: (Double) -> Double, _ b: Double) -> Double {
    if a > b {
        return 0
    }
    else {
        return term(a) + sum(term, next(a), next, b)
    }
} 
```

위에 선언한 sum 프로시저는 수의 범위를 나타내는 a, b 뿐만 아니라 프로시저를 인자로 받는 term과 next가 있다는 것을 주의해야 한다. sum을 사용하는 방식은 보통 프로시저와 동일하다. 

인자에 1을 더하는 프로시저 inc()와 sum_cubes를 정의하면 다음과 같다. 

```swift
func inc(_ n: Double) -> Double {
    return n + 1
}

func sum_cubes(_ a: Double, _ b: Double) -> Double {
    return sum(cube, a, inc, b)
}

sum_cubes(1, 10)
```

또 다른 예제를 살펴보자. 받은 대로 그대로 돌려주는 함수로 identity가 정의되어 있다면, 프로시저 sum으로 sum_integers를 만들어보자.

```swift
func identity(_ x: Double) -> Double {
    return x
}

func sum_integers(_ a: Double, _ b: Double) -> Double {
    return sum(identity, a, inc, b)
}

sum_integers(1, 10)
```

위에서 구현했던 pi_sum() 프로시저를 다시 한 번 선언해보자.

```swift
func pi_sum(_ a: Double, _ b: Double) -> Double {
    func pi_term(_ x: Double) -> Double {
        return 1.0 / (x * (x + 2))
    }
    func pi_next(_ x: Double) -> Double {
        return x + 4
    }
    return sum(pi_term, a, pi_next, b)
}

8 * pi_sum(1, 1000)
```

훨씬 복잡한 아주 작은 값 dx가 있을 때 함수 f를 a부터 사이에서 적분한 값은 다음과 같다. 

```swift
func integral(_ f : (Double) -> Double, _ a: Double, _ b: Double, _ dx: Double) -> Double {
    func add_dx(_ x: Double) -> Double {
        return x + dx
    }
    return sum(f, a + dx / 2, add_dx, b) * dx
}

integral(cube, 0, 1, 0.01)
integral(cube, 0, 1, 0.005)
```

##### 연습문제 1.29


##### 연습문제 1.30

