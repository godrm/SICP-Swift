
### ì´ì „ ëª©ì°¨

[1ì¥ í”„ë¡œì‹œì €ë¡œ ìš”ì•½í•˜ëŠ” ë°©ì‹](https://github.com/godrm/SICP-Swift/blob/master/Chapter1.md)

[ì´ì „ 1.1 The Elements of Programming](https://github.com/godrm/SICP-Swift/blob/master/1.1.md)

[ì´ì „ 1.2 Procedures and the Processes They Generate](https://github.com/godrm/SICP-Swift/blob/master/1.2.md)

## <a name="head1.3"></a> 1.3 ì°¨ìˆ˜ê°€ ë†’ì€ ê³ ì°¨ í”„ë¡œì‹œì €(í•¨ìˆ˜)ë¡œ ìš”ì•½í•˜ëŠ” ë°©ì‹ Formulating Abstractions with Higher-Order procedure

```swift
func cube(x: Int) -> Int {
    return x * x * x
}

func cube(x: Double) -> Double {
    return x * x * x
}
```

ì´ í”„ë¡œì‹œì €ëŠ” ì •ìˆ˜ì™€ ì‹¤ìˆ˜ ëª¨ë‘ ì„¸ì œê³±ì„ ê³„ì‚°í•˜ë„ë¡ êµ¬í˜„í•œ ê²ƒì´ë‹¤. ì›Œë‚™ ê°„ë‹¨í•œ ê³„ì‚°ì´ê¸° ë•Œë¬¸ì— ì´ë ‡ê²Œ ì„ ì–¸í•œ ê²ƒì„ ì‚¬ìš©í•˜ì§€ ì•Šê³ , `3 * 3 * 3` ë˜ëŠ” `x * x * x`ì²˜ëŸ¼ ê¸°ë³¸ ì—°ì‚°ìœ¼ë¡œ í’€ì–´ì„œ ì“¸ ìˆ˜ë„ ìˆë‹¤. ê°™ì€ ì„¸ì œê³±ì„ ê³„ì‚°í•˜ë”ë¼ë„ ì–¸ì–´ë¡œ ì„¸ì œê³±ì´ë¼ëŠ” ê³„ì‚°(ë˜ëŠ” ì—°ì‚°)ì„ ë‚˜íƒ€ë‚´ëŠ” ë‹¨ì–´ë¥¼ ì„ ì–¸í•˜ëŠ” ê²Œ ì¢‹ë‹¤. í”„ë¡œê·¸ë˜ë° ì–¸ì–´ëŠ” ë˜í’€ì´ë˜ëŠ” ê³„ì‚°ì„ ê°„ì¶”ë ¤ì„œ ëŒ€í‘œí•˜ëŠ” ì˜ë¯¸ìˆëŠ” ì´ë¦„ìœ¼ë¡œ ë¶™ì´ëŠ” ê²Œ ì¤‘ìš”í•˜ë‹¤. í”„ë¡œì‹œì €ë¥¼ ì„ ì–¸í•˜ëŠ” ê²ƒë„ ê·¸ ì¤‘ì— í•œ ê°€ì§€ ë°©ë²•ì´ë‹¤. 

ë‹¨ìˆœí•œ ê³„ì‚°ì„ í•˜ëŠ” ê²½ìš°ë§Œ ë´ë„ í”„ë¡œì‹œì €ê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ìˆ«ìë§Œ ë°›ì„ ìˆ˜ ìˆë‹¤ë©´, ìƒˆë¡œìš´ í‘œí˜„ìœ¼ë¡œ ì¶”ìƒí™”í•´ì„œ ì •ì˜í•˜ëŠ” ëŠ¥ë ¥ì€ ì œí•œë  ìˆ˜ ë°–ì— ì—†ë‹¤. ì´ëŸ°ì €ëŸ° í”„ë¡œê·¸ë¨ì—ì„œ ì—¬ëŸ¬ í”„ë¡œì‹œì €ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ì‹ì´ ë¹„ìŠ·í•œ ê²½ìš°ë¥¼ ì¢…ì¢… ë³¼ ìˆ˜ ìˆë‹¤. ê·¸ë˜ì„œ ë°˜ë³µí•˜ëŠ” ê³„ì‚° ë°©ì‹ì„ ê°„ì¶”ë¦¬ë ¤ë©´, ìˆ«ìëŠ” ë¬¼ë¡  ë‹¤ë¥¸ í”„ë¡œì‹œì €ë¥¼ ì¸ìë¡œ ë°›ê±°ë‚˜ ê²°ê³¼ë¡œ ë˜ëŒë ¤ ì£¼ëŠ” í”„ë¡œì‹œì €ë¥¼ ë§Œë“¤ ìˆ˜ ìˆì–´ì•¼ í•œë‹¤. ì´ì²˜ëŸ¼ í”„ë¡œì‹œì €ë¥¼ ë°ì´í„°ì²˜ëŸ¼ ì‚¬ìš©í•˜ëŠ” í”„ë¡œì‹œì €ë¥¼ ê³ ì°¨ í”„ë¡œì‹œì €( ë˜ëŠ” ê³ ì°¨ í•¨ìˆ˜) high-order function ë¼ê³  í•œë‹¤. 

### 1.3.1 í”„ë¡œì‹œì €ë¥¼ ì¸ìë¡œ ë°›ëŠ” í”„ë¡œì‹œì €

ë‹¤ìŒ ë‘ í•¨ìˆ˜ëŠ” ê°ê° aë¶€í„° bê¹Œì§€ ì •ìˆ˜ì˜ í•©ì„ êµ¬í•˜ëŠ” í”„ë¡œì‹œì €ì™€ ì •í•´ì§„ ë„“ì´ ì† ì •ìˆ˜ë¥¼ ì„¸ì œê³± í•˜ëŠ” í”„ë¡œì‹œì €ë‹¤. 

```swift
func sum_intergers(a: Int, b: Int) -> Int {
    if a > b {
        return 0
    }
    else {
        return a + sum_intergers(a + 1, b)
    }
}

func sum_cubes(a: Int, b: Int) -> Int {
    if a > b {
        return 0
    }
    else {
        return a + sum_cubes(a + 1, b)
    }
}
```

ì„¸ ë²ˆì§¸ í”„ë¡œì‹œì €ëŠ” ë‹¤ìŒ ìˆ˜ì—´ì—ì„œ ëª¨ë“  ë§ˆë””ë¥¼ ë”í•˜ëŠ” í”„ë¡œì‹œì €ë‹¤. 

```swift
func pi_sum(a: Double, b: Double) -> Double {
    if a > b {
        return 0
    }
    else {
        return 1.0 / (a * (a + 2)) + pi_sum(a + 4, b)
    }
}
```

ì—¬ê¸°ê¹Œì§€ í”„ë¡œì‹œì €ë¥¼ ì½ê³ ë‚˜ë©´ ì„¸ í”„ë¡œì‹œìê°€ ê°™ì€ ê³„ì‚° ë°©ë²•ì„ ì‚¬ìš©í•˜ê³  ìˆë‹¤ëŠ” ê²ƒì„ ëˆˆì¹˜ì±Œ ìˆ˜ ìˆë‹¤. í”„ë¡œì‹œì €ì˜ ì´ë¦„, ë§ˆë”” ê°’ aë¥¼ ë°›ì•„ì„œ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜, a ë‹¤ìŒ ê°’ì„ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜ë§Œ ë‹¤ë¥¼ ë¿ì´ë‹¤. ë”°ë¼ì„œ ë‹¤ìŒ í”„ë¡œì‹œì € í‹€ì—ì„œ name, term, next ë¹ˆ ì¹¸ë§Œ ì±„ìš°ë©´ ì„¸ ê°€ì§€ ëª¨ë“  í”„ë¡œì‹œì €ë¥¼ í‘œí˜„í•  ìˆ˜ ìˆë‹¤. 

```swift
func name(a: Double, b: Double) -> Double {
    if a > b {
        return 0
    }
    else {
        return term(a) + name(next(a), b)
    }
}
```

ì´ë ‡ê²Œ ì—¬ëŸ¬ í”„ë¡œì‹œì €ì— ê°™ì€ ê³„ì‚° ë°©ë²•ì„ ì ìš©í•  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì€ ì´ë¥¼ ê°„ì¶”ë¦´ ë•Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” í”„ë¡œì‹œì €ê°€ ë‚˜ì˜¬ ìˆ˜ ìˆë‹¤ëŠ” ì˜ë¯¸ë‹¤. ìˆ˜í•™ìë“¤ì€ ì•„ì£¼ ì˜¤ë˜ ì „ë¶€í„° ìˆ˜ì—´ ë§ˆë””ë¥¼ ë”í•˜ëŠ” ì¼ì„ ê°™ì€ ê³„ì‚° ë°©ë²•ìœ¼ë¡œ í‘œí˜„í•  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ì•Œì•˜ë‹¤. ê·¸ë ‡ê²Œ `ì‹œê·¸ë§ˆ í‘œí˜„ì‹`ì„ ë§Œë“¤ì—ˆë‹¤. 

name, term, next ë¹ˆ ìë¦¬ë¥¼ ì¸ì ì´ë¦„ì˜¤ ë°”ê¿”ì„œ í‘œí˜„í•´ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤. 

```swift
func sum(_ term: (Double) -> Double, _ a: Double, _ next: (Double) -> Double, _ b: Double) -> Double {
    if a > b {
        return 0
    }
    else {
        return term(a) + sum(term, next(a), next, b)
    }
} 
```

ìœ„ì— ì„ ì–¸í•œ sum í”„ë¡œì‹œì €ëŠ” ìˆ˜ì˜ ë²”ìœ„ë¥¼ ë‚˜íƒ€ë‚´ëŠ” a, b ë¿ë§Œ ì•„ë‹ˆë¼ í”„ë¡œì‹œì €ë¥¼ ì¸ìë¡œ ë°›ëŠ” termê³¼ nextê°€ ìˆë‹¤ëŠ” ê²ƒì„ ì£¼ì˜í•´ì•¼ í•œë‹¤. sumì„ ì‚¬ìš©í•˜ëŠ” ë°©ì‹ì€ ë³´í†µ í”„ë¡œì‹œì €ì™€ ë™ì¼í•˜ë‹¤. 

ì¸ìì— 1ì„ ë”í•˜ëŠ” í”„ë¡œì‹œì € inc()ì™€ sum_cubesë¥¼ ì •ì˜í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤. 

```swift
func inc(_ n: Double) -> Double {
    return n + 1
}

func sum_cubes(_ a: Double, _ b: Double) -> Double {
    return sum(cube, a, inc, b)
}

sum_cubes(1, 10)
```

ë˜ ë‹¤ë¥¸ ì˜ˆì œë¥¼ ì‚´í´ë³´ì. ë°›ì€ ëŒ€ë¡œ ê·¸ëŒ€ë¡œ ëŒë ¤ì£¼ëŠ” í•¨ìˆ˜ë¡œ identityê°€ ì •ì˜ë˜ì–´ ìˆë‹¤ë©´, í”„ë¡œì‹œì € sumìœ¼ë¡œ sum_integersë¥¼ ë§Œë“¤ì–´ë³´ì.

```swift
func identity(_ x: Double) -> Double {
    return x
}

func sum_integers(_ a: Double, _ b: Double) -> Double {
    return sum(identity, a, inc, b)
}

sum_integers(1, 10)
```

ìœ„ì—ì„œ êµ¬í˜„í–ˆë˜ pi_sum() í”„ë¡œì‹œì €ë¥¼ ë‹¤ì‹œ í•œ ë²ˆ ì„ ì–¸í•´ë³´ì.

```swift
func pi_sum(_ a: Double, _ b: Double) -> Double {
    func pi_term(_ x: Double) -> Double {
        return 1.0 / (x * (x + 2))
    }
    func pi_next(_ x: Double) -> Double {
        return x + 4
    }
    return sum(pi_term, a, pi_next, b)
}

8 * pi_sum(1, 1000)
```

í›¨ì”¬ ë³µì¡í•œ ì•„ì£¼ ì‘ì€ ê°’ dxê°€ ìˆì„ ë•Œ í•¨ìˆ˜ fë¥¼ aë¶€í„° ì‚¬ì´ì—ì„œ ì ë¶„í•œ ê°’ì€ ë‹¤ìŒê³¼ ê°™ë‹¤. 

```swift
func integral(_ f : (Double) -> Double, _ a: Double, _ b: Double, _ dx: Double) -> Double {
    func add_dx(_ x: Double) -> Double {
        return x + dx
    }
    return sum(f, a + dx / 2, add_dx, b) * dx
}

integral(cube, 0, 1, 0.01)
integral(cube, 0, 1, 0.005)
```

##### ì—°ìŠµë¬¸ì œ 1.29

```swift
func simpsons_rule_integral(f: (Double) -> Double, a: Double, b: Double, n: Double) -> Double {
    func helper(h: Double) -> Double {
        func y(_ k: Double) -> Double {
            return f((k*h) + a)
        }
        func term(k: Double) -> Double {
            if k == 0 || k == n {
                return y(k)
            }
            else if k.remainder(dividingBy: 2) == 0 {
                return 2 * y(k)
            }
            else {
                return 4 * y(k)
            }
        }
        return sum(term, 0, inc, n)
    }
    return helper(h: (b-a) / n )
}

simpsons_rule_integral(f: cube, a: 0, b: 1, n: 100)
simpsons_rule_integral(f: cube, a: 0, b: 1, n: 1000)
```

##### ì—°ìŠµë¬¸ì œ 1.30

```swift
func sum(term: (Double) -> Double, a: Double, next: (Double) -> Double, b: Double) -> Double {
    func iter(a: Double, result: Double) -> Double {
        if a > b {
            return result
        }
        else {
            return iter(a: next(a), result: result+term(a))
        }
    }
    return iter(a: a, result: 0)
}
```

##### ì—°ìŠµë¬¸ì œ 1.31

```swift
func product_r(term: (Double) -> Double, a: Double, next: (Double) -> Double, b: Double) -> Double { 
    if a > b {
        return 1
    }
    else {
        return term(a) * product_r(term: term, a: next(a), next: next, b: b)
    }
}

func product_i(term: (Double) -> Double, a: Double, next: (Double) -> Double, b: Double) -> Double { 
    func iter(_ a: Double, _ result : Double) -> Double {
        if a > b {
            return result
        }
        else {
            return iter(next(a), term(a) * result)
        }
    }
    return iter(a, 1)
}

product_r(term: identity, a:1, next:inc, b:5)
product_i(term: identity, a:1, next:inc, b:5)
```

##### ì—°ìŠµë¬¸ì œ 1.32

> ì¬ê·€ ë°©ì‹ 

```swift
func accumulate_r(combiner: (Double, Double) -> Double, null_value: Double, term: (Double) -> Double, a: Double, next: (Double) -> Double, b: Double) -> Double 
{
    if a > b {
        return null_value
    }
    else {
        return combiner(term(a), accumulate_r(combiner: combiner, null_value: null_value, 
                                              term: term, a: next(a), next: next, b: b))
    }
}
```

> ë°˜ë³µ ë°©ì‹

```swift
func accumulate_i(combiner: (Double, Double) -> Double, null_value: Double, term: (Double) -> Double, a: Double, next: (Double) -> Double, b: Double) -> Double 
{
    func iter(_ a: Double, _ result: Double) -> Double {
        if a > b {
            return result
        }
        else {
            return iter(next(a), combiner(term(a), result))
        }
    }
    return iter(a, null_value)
}

func sum_i(term: (Double) -> Double, a: Double, next: (Double) -> Double, b: Double) -> Double 
{
    func plus(_ x: Double, _ y: Double) -> Double {
        return x + y
    }
    return accumulate_i(combiner: plus, null_value: 0, term: term, a: a, next: next, b: b)
}

func product_r(term: (Double) -> Double, a: Double, next: (Double) -> Double, b: Double) -> Double {
    func times(_ x: Double, _ y: Double) -> Double {
        return x * y
    }
    return accumulate_i(combiner: times, null_value: 1, term: term, a: a, next: next, b: b)
}
```

##### ì—°ìŠµë¬¸ì œ 1.33

```swift
func filtered_accumulate(combiner: (Double, Double) -> Double, null_value: Double, term: (Double) -> Double, a: Double, next: (Double) -> Double, b: Double, filter: (Double) -> Bool) -> Double {
    if a > b {
        return null_value
    }
    else if filter(a){
        return combiner(term(a), filtered_accumulate(combiner: combiner, null_value: null_value, term: term, a: next(a), next: next, b: b, filter: filter))
    }
    else {
        return filtered_accumulate(combiner: combiner, null_value: null_value, term: term, a: next(a), next: next, b: b, filter: filter)
    }
}
```

## 1.3.2 í´ë¡œì €closureë¡œ ë‚˜íƒ€ë‚´ëŠ” í”„ë¡œì‹œì €

1.3.1ì ˆì—ì„œ sum()ì„ ë§Œë“¤ ë•Œì²˜ëŸ¼ pi_term() ì´ë‚˜ pi_next() ê°™ì€ í”„ë¡œì‹œì €ë¥¼ ì¸ìë¡œ ì „ë‹¬í•˜ê¸° ìœ„í•´ì„œ ë§¤ë²ˆ ì„ ì–¸í•˜ëŠ” ê²ƒì€ ê·€ì°®ì€ ì¼ì´ë‹¤. ê·¸ë˜ì„œ í•­ìƒ í”„ë¡œì‹œì €ë¥¼ ì„ ì–¸í•˜ëŠ” ëŒ€ì‹  'ì¸ìì— 4ë¥¼ ë”í•˜ê³  ëŒë ¤ì£¼ëŠ” í”„ë¡œì‹œì €' ë˜ëŠ” 'ì¸ìì™€ ì¸ìì— 2ë¥¼ ë”í•œ ê°’ì„ ê³±í•´ì„œ ì—­ìˆ˜ë¥¼ ê³„ì‚°í•˜ëŠ” í”„ë¡œì‹œì €'ë¥¼ ë°”ë¡œ ì„ ì–¸í•˜ëŠ” ê²Œ í¸ë¦¬í•˜ë‹¤. í´ë¡œì €ë¼ëŠ” í˜•ì‹ì´ ì´ëŸ° ë¬¸ì œë¥¼ í‘¸ëŠ” ë° ë„ì›€ì´ ëœë‹¤. 

ìŠ¤ìœ„í”„íŠ¸ì—ì„œ í´ë¡œì €ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì„ ì–¸í•œë‹¤. ê·¸ë ‡ì§€ë§Œ í´ë¡œì €ë¥¼ ì–´ë”˜ê°€ì— ë‹´ì§€ ì•ŠëŠ”ë‹¤ë©´ ì´ ìƒíƒœ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ì§€ëŠ” ëª»í•œë‹¤.

```swift
{ x in x + 4 }
{ x in 1 / (x * (x + 2)) }
```

í´ë¡œì €ë¥¼ ë‹¤ìŒê³¼ ê°™ì´ ìƒìˆ˜ì™€ í•¨ê»˜ ì„ ì–¸í•  ìˆ˜ ìˆë‹¤.
```swift
let k = { x in x + 4 }
let z = { x in 1 / (x * (x + 2)) }
```

ë˜ëŠ” integral() ê°™ì€ ë‹¤ë¥¸ í•¨ìˆ˜ë¥¼ ì„ ì–¸í•  ë•Œ ë³´ì¡° í•¨ìˆ˜ë¥¼ ì„ ì–¸í•˜ì§€ ì•Šê³  ì§ì ‘ ì„ ì–¸í•  ìˆ˜ ìˆë‹¤. 
```swift
func pi_sum(a: Double, b: Double) -> Double {
    return sum({x in 1 / (x * (x + 2))}, 
               a, 
               {x in x + 4},
               b
    )
}

func integral(_ f : (Double) -> Double, _ a: Double, _ b: Double, _ dx: Double) -> Double {
    return sum(f, a + dx / 2, { x in x + dx }, b) * dx
}
```

ì´ì²˜ëŸ¼ í•¨ìˆ˜ë¥¼ ì„ ì–¸í•˜ëŠ” ê²ƒê³¼ í° ì°¨ì´ëŠ” ì—†ì§€ë§Œ, ì´ë¦„ì„ ë¶™ì´ì§€ ì•Šê³  ë§¤ê°œ ë³€ìˆ˜ ìë¦¬ì— ë°”ë¡œ ë„£ì„ ìˆ˜ ìˆë‹¤. 

`func plus4(x: Double) -> Double { return x + 4 }`ë¡œ ì„ ì–¸í•œ í•¨ìˆ˜ê°€ ìˆë‹¤ê³  ê°€ì •í•˜ì. 
ì´ í”„ë¡œì‹œì €ëŠ” `let plus4 = { x in x + 4 }`ì²˜ëŸ¼ í´ë¡œì €ë¥¼ ìƒìˆ˜ì— ì„ ì–¸í•œ ê²ƒê³¼ ê°™ë‹¤. 

í´ë¡œì € ë¬¸ë²• ë‚´ìš©ì„ í’€ì–´ì„œ ì„¤ëª…í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤. 

![lambda]()

í•¨ìˆ˜ ëŒ€ì‹  ê°’ì„ ì²˜ë¦¬í•˜ëŠ” ì—°ì‚°ìê°€ ìˆëŠ” í‘œí˜„ì‹ì²˜ëŸ¼, ì—°ì‚°ì ëŒ€ì‹  í´ë¡œì €ë¥¼ ì„ ì–¸í•  ìˆ˜ë„ ìˆë‹¤. 

`let k = {(x, y, z) in x + y + square(z)}(1,2,3)` 

#### letìœ¼ë¡œ ê°‡íŒ ë³€ìˆ˜ ë§Œë“¤ê¸°

```swift
func f(x: Double, y: Double) -> Double {
    func f_helper(_ a: Double, _ b: Double) -> Double {
        return x * square(a) + y*b + a*b
    }
    return f_helper(1 + x*y, 1-y)
}
```

```swift
func f_closure(x: Double, y: Double) -> Double {
    return { a, b in x * square(a) + y*b + a*b }(1 + x*y, 1-y)
}
```

```swift
func f_local(x: Double, y: Double) -> Double {
    let a = 1 + x*y
    let b = 1 - y
    return x * square(a) + y*b + a*b
}
```

##### ì—°ìŠµë¬¸ì œ 1.34

```swift
func f(g: (Double) -> Double) -> Double {
    return g(2)
}

f(g: square)
> 4
f(g: { z in z * (z + 1)})
> 6
```

ìœ„ì— ì½”ë“œë¥¼ ì‹¤í–‰ì´ ë˜ì§€ë§Œ, `f(g: f)` í˜•ì‹ì€ ë™ì‘í•˜ì§€ ì•ŠëŠ”ë‹¤. ìŠ¤ìœ„í”„íŠ¸ëŠ” f() íƒ€ì…ì´ g() íƒ€ì…ê³¼ ë‹¤ë¥´ê¸° ë•Œë¬¸ì— ì»´íŒŒì¼ ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤.


## 1.3.3 ì¼ë°˜ ë°©ë²•ì„ í‘œí˜„í•˜ëŠ” í”„ë¡œì‹œì €

1.1.4ì ˆì—ì„œëŠ” ê³„ì‚°í•˜ëŠ” ë°©ë²•ì—ë§Œ ì§‘ì¤‘í•´ì„œ í”„ë¡œì‹œì €ë¡œ ìš”ì•½í•˜ëŠ” ë°©ë²•ì„ ë‹¤ë£¨ì—ˆë‹¤. 1.3.1ì ˆì—ì„œëŠ” ë§Œë“  integral ì ë¶„ ê³„ì‚°ì‹ì²˜ëŸ¼ ì°¨ìˆ˜ ë†’ì€ í”„ë¡œì‹œì €ë¥¼ ë§Œë“¤ì–´ì„œ ì“°ì„ìƒˆë¥¼ ëŠ˜ë¦´ ìˆ˜ ìˆì—ˆë‹¤.

#### ì´ë¶„ë²•ìœ¼ë¡œ ë°©ì •ì‹ì˜ ê·¼ ì°¾ê¸°
ì´ë¶„ë²• half-interval methodëŠ” ì–´ë–¤ ë„ˆë¹„ë¥¼ ë°˜ìœ¼ë¡œ ë‚˜ëˆ„ëŠ” ë°©ë²•ìœ¼ë¡œ, ì—°ì† í•¨ìˆ˜ fì—ì„œ f(x)=0ì„ ë§Œì¡±í•˜ëŠ” ê·¼ì„ ì°¾ëŠ” ë°©ë²•ì´ë‹¤. ê³„ì‚°ì„ ë°˜ë³µí•  ë•Œë§ˆë‹¤ ê°’ì„ ì°¾ì•„ì•¼ í•  ë„“ì´ê°€ ì ˆë°˜ìœ¼ë¡œ ì¤„ì–´ë“ ë‹¤. Lì´ ì²˜ìŒ ë„“ì´, Tê°€ í—ˆìš©ì˜¤ì°¨ error toleranceì¼ ë•Œ ê³„ì‚° ë‹¨ê³„ëŠ” ğœ£(log(L / T)) ì •ë„ê°€ ëœë‹¤. 

```swift
func search(_ f: (Double)-> Double, _ neg_point: Double, _ pos_point: Double) -> Double {
    let midpoint = average(neg_point, pos_point)
    if close_enough(neg_point, pos_point) {
        return midpoint
    }
    let test_value = f(midpoint)
    if positive(test_value) {
        return search(f, neg_point, midpoint)
    }
    else if negative(test_value) {
        return search(f, midpoint, pos_point)
    }
    return midpoint
}

func close_enough(_ x: Double, _ y: Double) -> Bool {
    return abs(x - y) < 0.001
}

func average(_ x: Double, _ y: Double) -> Double {
    return (x + y) / 2.0
}

func positive(_ x: Double) -> Bool {
    return x > 0
}

func negative(_ x: Double) -> Bool {
    return x < 0
}

func half_interval_method(_ f:(Double)->Double, _ a: Double, _ b: Double) -> Double? {
    let a_value = f(a)
    let b_value = f(b)
    if negative(a_value) && positive(b_value) {
        return search(f, a, b)
    }
    else if negative(b_value) && positive(a_value) {
        return search(f, b, a)
    }
    print("Values are not of opposite sign \(a), \(b)")
    return nil
}

print(half_interval_method(sin, 2.0, 4.0))
print(half_interval_method({ (x:Double) in (x*x*x) - (2*x) - 3 }, 1.0, 2.0))
```


#### ê³ ì •ì  ì°¾ê¸° í•¨ìˆ˜

íŠ¹ì •í•œ ìˆ˜ xì— ëŒ€í•´ f(x) = xê°€ ì°¸ì´ë©´ xë¥¼ fì˜ ê³ ì •ì  fixed pointë¼ê³  í•œë‹¤. 
í•¨ìˆ˜ fì— ì„ì‹œê°’ì„ ì£¼ê³  ë°˜ë³µí•´ì„œ fë¥¼ ê³„ì‚°í•˜ë‹¤ê°€ ê·¸ ê°’ì´ í¬ê²Œ ë°”ë€Œì§€ ì•Šìœ¼ë©´ fì˜ ê³ ì •ì ì„ ì°¾ì„ ìˆ˜ ìˆë‹¤. 

```swift
let tolerance = 0.0001
func fixed_point(_ f:(Double)->Double, _ first_guess:Double) -> Double {
    func close_enough(_ x: Double, _ y: Double) -> Bool {
        return abs(x - y) < tolerance
    }
    func try_with(guess: Double) -> Double {
        let next = f(guess)
        if close_enough(guess, next) {
            return next
        }
        else {
            return try_with(guess: next)
        }
    }
    return try_with(guess: first_guess)
}

fixed_point(cos, 1.0)
fixed_point( { y in sin(y) + cos(y)} , 1.0)
```

1.1.7ì ˆì—ì„œ ì œê³±ê·¼ì„ ì°¾ë˜ ë°©ë²•ì„ ê³ ì •ì  ì°¾ëŠ” ë°©ì‹ìœ¼ë¡œ í‘œí˜„í•˜ë©´ `y = x / y` ê°€ ë˜ëŠ” ê³ ì •ì ì„ ì°¾ìœ¼ë©´ ëœë‹¤. 

```swift
func sqrt_y(x: Double) -> Double {
    return fixed_point({ y in x / y}, 1.0)
}
```

í•˜ì§€ë§Œ ì´ë ‡ê²Œ êµ¬í˜„í•˜ë©´ ì œê¸‰ê·¼ì— ê°€ê¹Œì›Œì§€ì§€ ì•Šê³ , ê³ ì •ì  ê·¼ì²˜ë¥¼ ì™”ë‹¤ê°”ë‹¤ ë°˜ë³µí•  ë¿ì´ë‹¤. 
y ë‹¤ìŒ ê°’ì´ x/y ëŒ€ì‹  `(y + x/y)/2` ê°€ ë˜ë„ë¡ yì™€ x/y í‰ê· ê°’ì„ êµ¬í•˜ë©´ ëœë‹¤. 

```swift
func sqrt(x: Double) -> Double {
    return fixed_point({ y in average(y, (x / y))}, 1.0)
}
```


##### ì—°ìŠµë¬¸ì œ 1.35

`fixed_point( { x in 1 + (1 / x)}, 1.0 )`

##### ì—°ìŠµë¬¸ì œ 1.36

> ì¶œë ¥í•˜ëŠ” ë²„ì „ê³¼ í‰ê· ê°’ìœ¼ë¡œ ì°¾ì•„ê°€ëŠ” ë²„ì „

```swift
let tolerance = 0.0001
func fixed_point(_ f:(Double)->Double, _ first_guess:Double) -> Double {
    func close_enough(_ x: Double, _ y: Double) -> Bool {
        return abs(x - y) < tolerance
    }
    func try_with(guess: Double) -> Double {
        print("guess = \(guess)")
        let next = f(guess)
        if close_enough(guess, next) {
            return next
        }
        else {
            return try_with(guess: next)
        }
    }
    return try_with(guess: first_guess)
}

func fixed_point_average(_ f:(Double)->Double, _ first_guess:Double) -> Double {
    func close_enough(_ x: Double, _ y: Double) -> Bool {
        return abs(x - y) < tolerance
    }
    func try_with(guess: Double) -> Double {
        print("guess = \(guess)")
        let next = (guess + f(guess)) / 2
        if close_enough(guess, next) {
            return next
        }
        else {
            return try_with(guess: next)
        }
    }
    return try_with(guess: first_guess)
}
```

##### ì—°ìŠµë¬¸ì œ 1.37

> ë°˜ë³µ í”„ë¡œì‹œì €

```swift
func continue_frac_r(n: (Double)->Double, d: (Double)->Double, k: Double) -> Double {
    func fraction(i: Double) -> Double {
        if i > k {
            return 0
        }
        return n(i) / (d(i) + fraction(i: i+1))
    }
    return fraction(i: 1)
}

continue_frac_r(n: { i in 1.0 }, d: { i in 1.0 }, k: 20)
```

> ì ˆì°¨ í”„ë¡œì‹œì €

```swift
func continue_frac_i(n: (Double)->Double, d: (Double)->Double, k: Double) -> Double {
    func fraction(_ i: Double, _ current: Double) -> Double {
        if i == 0 {
            return current
        }
        return fraction(i - 1, n(i) / (d(i) + current))
    }
    return fraction(k, 0)
}

continue_frac_i(n: { i in 1.0 }, d: { i in 1.0 }, k: 20)
```

##### ì—°ìŠµë¬¸ì œ 1.38

```swift
print(2 + continue_frac_r(n: { i in 1.0 }, 
                    d: { i in ((i + 1).remainder(dividingBy: 3) < 1) ? 2 * (i+1) / 3 : 1.0}, 
                    k: 20))
```

##### ì—°ìŠµë¬¸ì œ 1.39

```swift
func tan_cf(x: Double, k: Double) -> Double {
    return continue_frac_i(n: { i in i == 1 ? x : -x * x }, 
                            d: { i in 2 * i - 1}, k: k)
}

print(tan_cf(x: 3.14 / 2.0, k: 20))
```

## 1.3.4 í”„ë¡œì‹œì €ë¥¼ ë§Œë“œëŠ” í”„ë¡œì‹œì € Procedures as Returned Values

í”„ë¡œì‹œì €ë¥¼ ë§¤ê°œ ë³€ìˆ˜ë¡œ ë°›ì•„ ì‚¬ìš©í•˜ë©´ ì–¸ì–´ í‘œí˜„ë ¥ì´ ì¢‹ì•„ì§€ëŠ” ê²ƒì²˜ëŸ¼, í”„ë¡œì‹œì €ë¥¼ ê²°ê³¼ ê°’ìœ¼ë¡œ ëŒë ¤ì¤„ ìˆ˜ ìˆìœ¼ë©´ í‘œí˜„ë ¥ì„ í•œì¸µ ë” ëŒì–´ ì˜¬ë¦´ ìˆ˜ ìˆë‹¤. 

ì•ì„œ 1.3.3ì ˆì—ì„œ ê³ ì •ê°’ì„ ì°¾ëŠ” ë¬¸ì œë¥¼ ë˜ì§šì–´ë³´ì. ì´ ë•Œ ì–´ë¦¼ê°’ì„ í‰ê· ë‚´ì„œ ì¦ì•„ë“œëŠ” ë°©ë²•ì„ ì‚¬ìš©í–ˆì—ˆë‹¤. í‰ê·  ì¦ì•„ë“¤ê¸° ë°©ì‹ì„ í‘œí˜„í•˜ë©´ ë‹¤ìŒ ì˜ˆì œ ì½”ë“œì™€ ê°™ë‹¤.

```swift
func average_damp(f: @escaping (Double)->Double) -> (Double) -> Double {
    return { x in average(x, f(x)) }
}

average_damp(f: square)(10)
```

average_damp() í”„ë¡œì‹œì €ëŠ” fë¼ëŠ” í•¨ìˆ˜ fë¥¼ ì¸ìë¡œ ì „ë‹¬ë°›ì•„ì„œ, xì™€ f(x)ì— í‰ê· ê°’ì„ êµ¬í•˜ëŠ” í´ë¡œì €ë¡œ ë§Œë“  í”„ë¡œì‹œì €ë¥¼ ë‚´ë†“ëŠ”ë‹¤. ì´ í”„ë¡œì‹œì €ë¥¼ í™œìš©í•´ì„œ ì œê³±ê·¼ í”„ë¡œì‹œì €ë¥¼ ë‹¤ì‹œ ì‘ì„±í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```swift
func sqrt(x: Double) -> Double {
    fixed_point(average_damp(f: { y in x / y}), 1.0)
}

sqrt(x: 5)
```

1.1.7ì ˆì—ì„œ ë§Œë“  ì œê³±ê·¼ í”„ë¡œì‹œì €ì™€ ë¹„êµí•´ë³´ë©´, ê°™ì€ ê³„ì‚° ê³¼ì •ì„ ë‚˜íƒ€ë‚´ì§€ë§Œ ì§€ê¸ˆì²˜ëŸ¼ ë” ê°„ì¶”ë¦´ìˆ˜ë¡ ê³„ì‚° ë°©ë²•ì´ ë” ëª…í™•í•˜ê²Œ ë“œëŸ¬ë‚œë‹¤ëŠ” ê²ƒì´ë‹¤. ê³„ì‚° ë°©ë²• ìì²´ëŠ” í•˜ë‚˜ë¼ë„ ì´ë¥¼ í”„ë¡œì‹œì €ë¡œ ë‚˜íƒ€ë‚´ëŠ” ë°©ë²•ì€ ì—¬ëŸ¬ ê°€ì§€ê°€ ìˆê³ , ê²½í—˜ì´ ë§ì€ ì¢‹ì€ í”„ë¡œê·¸ë˜ë¨¸ë¼ë©´ ê·¸ ì¤‘ì—ì„œë„ ê³„ì‚° ë°©ë²•ì„ ëª…í™•í•˜ê²Œ í‘œí˜„í•  ìˆ˜ ìˆëŠ” í”„ë¡œì‹œì €ë¥¼ ì‘ì„±í•˜ë ¤ê³  í•œë‹¤. ì œê³±ê·¼ì„ ì‘ìš©í•´ë³´ê¸° ìœ„í•´ì„œ, xì˜ ì„¸ì œê³±ê·¼ì€ í•¨ìˆ˜ y â†’ x/y<sup>2</sup> ê³ ì •ì ì´ë¼ëŠ” ì‚¬ì‹¤ì„ ë°”íƒ•ìœ¼ë¡œ ì„¸ì œê³±ê·¼ í”„ë¡œì‹œì €ë¥¼ ì‘ì„±í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```swift
func cube_root(x: Double) -> Double {
    fixed_point(average_damp(f: { y in x / square(y)}), 1.0)
}

cube_root(x: 27)
```

#### ë‰´íŠ¼ ë°©ë²•

x â†’ g(x)ê°€ ë¯¸ë¶„ë˜ëŠ” í•¨ìˆ˜ë¼ë©´, g(x)=0 ë°©ì •ì‹  ê·¼ì€ ë‹¤ìŒê³¼ ê°™ì€ f(x)ì˜ ì •ì ê³¼ ê°™ë‹¤.
f(x) = x - g(x) / Dg(x)

`ë¯¸ë¶„`ì€ í‰ê·  ì¦ì•„ë“¤ê¸°ì™€ ë§ˆì°¬ê°€ì§€ë¡œ ì–´ë–¤ í•¨ìˆ˜ë¥¼ ë‹¤ë¥¸ í•¨ìˆ˜ë¡œ ë°”ê¾¸ëŠ” ê²ƒì´ë‹¤. x â†’ x<sup>3</sup> ì— ëŒ€í•œ ë¯¸ë¶„ì€ í•¨ìˆ˜ x â†’ 3x<sup>2</sup> ì´ë‹¤. 

gê°€ í•¨ìˆ˜ì´ê³  dxê°€ ì•„ì£¼ ì‘ì€ ê°’ì´ë©´, xì—ì„œ gë¥¼ ë¯¸ë¶„í•œ DgëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤. 

[ë¯¸ë¶„ ìˆ˜ì‹]

```swift
let dx = 0.00001
func deriv(g: @escaping (Double) -> Double) -> (Double) -> Double {
    return { x in (g(x + dx) - g(x)) / dx }
}

deriv(g: cube)(5)
```

deriv() ë¯¸ë¶„ í”„ë¡œì‹œì €ë¥¼ ì„ ì–¸í•˜ê³  x â†’ x<sup>3</sup>ì„ 5ì—ì„œ ë¯¸ë¶„í•œ ê°’ì„ ê³„ì‚°í•  ìˆ˜ ìˆë‹¤. 
derivë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë‰´íŠ¼ ë°©ë²•ì„ ê³ ì •ì  ì°¾ëŠ” ë°©ë²•ìœ¼ë¡œ ë‚˜íƒ€ë‚´ë³´ì. 

```swift
func newton_transform(g: @escaping (Double)->Double) -> (Double) -> Double {
    return { x in x - g(x) / deriv(g: g)(x)}
}

func newtons_method(g: @escaping (Double)->Double, guess: Double) -> Double {
    return fixed_point(newton_transform(g: g), guess)
}

func sqrt_newton(x: Double) -> Double {
    return newtons_method(g: { y in square(y) - x}, guess: 1.0)
}

sqrt_newton(x: 9)
```

#### ìš”ì•½Abstractionsê³¼ ì¼ê¸‰ í”„ë¡œì‹œì € first-class procedures

ê³ ì •ì  ì°¾ê¸°ë‚˜ ë‰´íŠ¼ ë°©ë²•ì²˜ëŸ¼ ì¼ë°˜ì ì¸ ìˆ˜í•™ ê³„ì‚° ë°©ë²•ì„ `ì œê³±ê·¼ ì°¾ê¸°` ë¬¸ì œ í•´ê²°ì„ ìœ„í•´ì„œ ì–´ë–»ê²Œ í™œìš©í•˜ëŠ” ì§€ ì‚´í´ë´¤ë‹¤. ë‰´íŠ¼ ë°©ë²• ë‚´ë¶€ë„ ê³ ì •ì  ì°¾ê¸°ë¡œ í•´ê²°í•  ìˆ˜ ìˆìœ¼ë‹ˆê¹Œ ê²°êµ­ ê³ ì •ì  ì°¾ê¸°ë¥¼ ì‘ìš©í•´ì„œ ì œê³±ê·¼ì„ ì°¾ì„ ìˆ˜ ìˆì—ˆë‹¤. ì´ ê³¼ì •ì„ ìš”ì•½í•´ë³´ì.

```swift
func fixed_point_of_transform(g: @escaping (Double)->Double, transform: (@escaping (Double)->Double) -> (Double)->Double, guess: Double) -> Double {
    fixed_point(transform(g), guess)
}

func sqrt_transform(x: Double) -> Double {
    return fixed_point_of_transform(g: { y in x / y }, transform: average_damp, guess: 1.0)
}

sqrt_transform(x: 25)
```

ì´ë ‡ê²Œ ë³µì¡í•œ ê³„ì‚°ì„ ìš”ì•½í•˜ê¸° ìœ„í•´ì„œ ë¬¶ìŒ í”„ë¡œì‹œì € compound procedureê°€ ì–¼ë§ˆë‚˜ ì¤‘ìš”í•œ ì§€ ì•Œ ìˆ˜ ìˆë‹¤. ì´ë ‡ê²Œ ì°¨ìˆ˜ ë†’ì€ í”„ë¡œì‹œì €ê°€ í”„ë¡œì‹œì €ë¥¼ ë°›ê±°ë‚˜ ë˜ëŒë ¤ì£¼ëŠ” ë°©ì‹ìœ¼ë¡œ ì¼ë°˜ì ì¸ ê³„ì‚° ë°©ë²•ì„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤. 

í”„ë¡œê·¸ë˜ë¨¸ëŠ” í”„ë¡œê·¸ë˜ë° ê³¼ì •ì—ì„œ ì‘ì„±í•œ ì ˆì°¨ë¥¼ ë†“ê³ , ê·¸ ì¤‘ì—ì„œ ê°„ì¶”ë¦´ ê²Œ ë¬´ì—‡ì¸ì§€ ì°¾ì•„ë‚´ê³  ë” ë†’ì€ í‘œí˜„ ìˆ˜ë‹¨ìœ¼ë¡œ ë§Œë“¤ê¸° ìœ„í•´ ë…¸ë ¥í•´ì•¼ í•œë‹¤. ë” ì´ìƒ ìš”ì•½í•˜ì§€ ëª»í•  ë•Œê¹Œì§€ ëª¨ë“  í”„ë¡œê·¸ë¨ì„ ìš”ì•½í•˜ë¼ëŠ” ê²Œ ì•„ë‹ˆë‹¤. ì–´ëŠ ì •ë„ê¹Œì§€ ìš”ì•½í•´ì•¼ ë‹¤ë¥¸ ë¬¸ì œë¥¼ í’€ ë•Œ ë‹¤ì‹œ ì“¸ ìˆ˜ ìˆë„ë¡ ì¼ë°˜ í‘œí˜„ ìˆ˜ë‹¨ì´ ë˜ëŠ”ì§€ë„ ì‹ ê²½ì¨ì•¼ í•œë‹¤. ì°¨ìˆ˜ ë†’ì€ í”„ë¡œì‹œì €ê°€ í”„ë¡œì‹œì €ë¥¼ ê°’(ë°ì´í„°)ë¡œ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ê·¸ë˜ì„œ ì¤‘ìš”í•˜ë‹¤. 

í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì—ì„œëŠ” ê³„ì‚° ê³¼ì •ì—ì„œ ì–´ë–¤ ê¸°ëŠ¥ì„ ìš°ì„ ì ìœ¼ë¡œ ì–´ë–»ê²Œ ë‹¤ë£¨ì–´ì•¼ í•˜ëŠ”ì§€ ì œì•½ì„ ê±¸ì–´ë‘”ë‹¤. ê°€ì¥ ì œì•½ì´ ì ì€ ê²ƒì„ ì¼ë“±ê¸‰ first-classì— ì†í•œë‹¤ê³  ë¶€ë¥¸ë‹¤. 

ì¼ë“±ê¸‰ì´ ëˆ„ë¦¬ëŠ” íŠ¹ê¶Œì€ ë‹¤ìŒê³¼ ê°™ë‹¤. 
- ë³€ìˆ˜ ì´ë¦„ì„ ë¶™ì—¬ì„œ ë³€ìˆ˜ì˜ ê°’ì´ ë  ìˆ˜ ìˆë‹¤. (referred to name)
- í”„ë¡œì‹œì € ì¸ìë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. (passed as arguments)
- í”„ë¡œì‹œì €ì˜ ê²°ê³¼ë¡œ ë§Œë“¤ì–´ì§ˆ ìˆ˜ ìˆë‹¤. (returned as the result)
- ë°ì´í„° êµ¬ì¡° ì†ì— ì§‘ì–´ ë„£ì„ ìˆ˜ ìˆë‹¤. (included in data structures)

ìŠ¤ìœ„í”„íŠ¸ë„ í•¨ìˆ˜(í”„ë¡œì‹œì €)ë¥¼ ì¼ë“±ê¸‰ìœ¼ë¡œ ë‹¤ë£° ìˆ˜ ìˆë‹¤. 

##### ì—°ìŠµ ë¬¸ì œ 1.40

```swift
func cubic(a: Double, b: Double, c: Double) -> (Double) -> Double {
    return { x in cube(x: x) + a * square(x) + b * x + c }
}
```

##### ì—°ìŠµ ë¬¸ì œ 1.41

```swift
func double(f: @escaping (Double) -> Double) -> (Double) -> Double {
    return { x in f(f(x)) }
}
```

##### ì—°ìŠµ ë¬¸ì œ 1.42

```swift
func compose(f: @escaping (Double) -> Double, g: @escaping (Double) -> Double) -> (Double) -> Double {
    return { x in f(g(x))}
}
```

##### ì—°ìŠµ ë¬¸ì œ 1.43

```swift
func compose(f: @escaping (Double) -> Double, g: @escaping (Double) -> Double) -> (Double) -> Double {
    return { x in f(g(x))}
}

func repeated(f: @escaping (Double) -> Double, n: Double) -> (Double) -> Double {
    if n == 0 {
        return { x in x }
    }
    return compose(f: f, g: repeated(f: f, n: n-1))
}
```

##### ì—°ìŠµ ë¬¸ì œ 1.44

```swift
func compose(f: @escaping (@escaping (Double) -> Double) -> (Double) -> Double, g: @escaping (@escaping (Double) -> Double) -> (Double) -> Double) -> (@escaping (Double) -> Double) -> (Double) -> Double {
    return { x in f(g(x))}
}

func repeated(f: @escaping (@escaping (Double) -> Double) -> (Double) -> Double, n: Double) -> (@escaping (Double) -> Double) -> (Double) -> Double {
    if n == 0 {
        return { x in x }
    }
    return compose(f: f, g: repeated(f: f, n: n-1))
}


let dx = 0.00001
func smooth(f: @escaping (Double) -> Double) -> (Double) -> Double {
    return { x in (f(x - dx) + f(x) + f(x + dx)) / 3 }
}

func n_fold_smooth(f: @escaping (Double) -> Double, n: Double) -> (Double) -> Double {
    return repeated(f: smooth, n: n)(f)
}
```

##### ì—°ìŠµ ë¬¸ì œ 1.45

```swift
func fast_expt_iter(_ a: Double, _ b: Double, _ n: Double) -> Double{
    if n == 0 {
        return a
    }
    else if n.remainder(dividingBy: 2) == 0 {
        return fast_expt_iter(a, b*b, n/2)
    }
    else {
        return fast_expt_iter(a*b, b, n-1)
    }
}

func fast_expt(b: Double, n: Double) -> Double {
    return fast_expt_iter(1, b, n)
}

func nth_root(n: Double, x: Double) -> Double {
    return fixed_point(repeated(f: average_damp, 
                                n: floor(log(n)))({ y in x / fast_expt(b: y, n: n-1)}),
                                1.0) 
}

nth_root(n: 3, x: 2)
```

##### ì—°ìŠµ ë¬¸ì œ 1.46

```swift
func good_enough(_ guess: Double, _ x: Double) -> Bool {
    return abs(square(guess) - x) < 0.0001
}

func improve(_ guess: Double, _ x: Double) -> Double {
    return average(guess, x / guess)
}

func iterative_improve(good_enough: @escaping (Double) -> Bool, 
                       improve: @escaping (Double) -> Double) -> (Double) -> Double {
    func iterate(guess: Double) -> Double {
        if good_enough(guess) {
            return guess
        }
        return iterate(guess: improve(guess))
    }
    return iterate
}

func sqrt_improve(x: Double) -> (Double) -> Double {
    return iterative_improve(good_enough: { y in good_enough(y, x)}, improve: { y in improve(y, x)})
}

sqrt_improve(x: 49)(1.0)
```


