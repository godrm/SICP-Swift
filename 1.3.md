
### ì´ì „ ëª©ì°¨

[1ì¥ í”„ë¡œì‹œì €ë¡œ ìš”ì•½í•˜ëŠ” ë°©ì‹](https://github.com/godrm/SICP-Swift/blob/master/Chapter1.md)

[ì´ì „ 1.1 The Elements of Programming](https://github.com/godrm/SICP-Swift/blob/master/1.1.md)

[ì´ì „ 1.2 Procedures and the Processes They Generate](https://github.com/godrm/SICP-Swift/blob/master/1.2.md)

## <a name="head1.3"></a> 1.3 ì°¨ìˆ˜ê°€ ë†’ì€ ê³ ì°¨ í”„ë¡œì‹œì €(í•¨ìˆ˜)ë¡œ ìš”ì•½í•˜ëŠ” ë°©ì‹ Formulating Abstractions with Higher-Order procedure

```swift
func cube(x: Int) -> Int {
    return x * x * x
}

func cube(x: Double) -> Double {
    return x * x * x
}
```

ì´ í”„ë¡œì‹œì €ëŠ” ì •ìˆ˜ì™€ ì‹¤ìˆ˜ ëª¨ë‘ ì„¸ì œê³±ì„ ê³„ì‚°í•˜ë„ë¡ êµ¬í˜„í•œ ê²ƒì´ë‹¤. ì›Œë‚™ ê°„ë‹¨í•œ ê³„ì‚°ì´ê¸° ë•Œë¬¸ì— ì´ë ‡ê²Œ ì„ ì–¸í•œ ê²ƒì„ ì‚¬ìš©í•˜ì§€ ì•Šê³ , `3 * 3 * 3` ë˜ëŠ” `x * x * x`ì²˜ëŸ¼ ê¸°ë³¸ ì—°ì‚°ìœ¼ë¡œ í’€ì–´ì„œ ì“¸ ìˆ˜ë„ ìˆë‹¤. ê°™ì€ ì„¸ì œê³±ì„ ê³„ì‚°í•˜ë”ë¼ë„ ì–¸ì–´ë¡œ ì„¸ì œê³±ì´ë¼ëŠ” ê³„ì‚°(ë˜ëŠ” ì—°ì‚°)ì„ ë‚˜íƒ€ë‚´ëŠ” ë‹¨ì–´ë¥¼ ì„ ì–¸í•˜ëŠ” ê²Œ ì¢‹ë‹¤. í”„ë¡œê·¸ë˜ë° ì–¸ì–´ëŠ” ë˜í’€ì´ë˜ëŠ” ê³„ì‚°ì„ ê°„ì¶”ë ¤ì„œ ëŒ€í‘œí•˜ëŠ” ì˜ë¯¸ìˆëŠ” ì´ë¦„ìœ¼ë¡œ ë¶™ì´ëŠ” ê²Œ ì¤‘ìš”í•˜ë‹¤. í”„ë¡œì‹œì €ë¥¼ ì„ ì–¸í•˜ëŠ” ê²ƒë„ ê·¸ ì¤‘ì— í•œ ê°€ì§€ ë°©ë²•ì´ë‹¤. 

ë‹¨ìˆœí•œ ê³„ì‚°ì„ í•˜ëŠ” ê²½ìš°ë§Œ ë´ë„ í”„ë¡œì‹œì €ê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ìˆ«ìë§Œ ë°›ì„ ìˆ˜ ìˆë‹¤ë©´, ìƒˆë¡œìš´ í‘œí˜„ìœ¼ë¡œ ì¶”ìƒí™”í•´ì„œ ì •ì˜í•˜ëŠ” ëŠ¥ë ¥ì€ ì œí•œë  ìˆ˜ ë°–ì— ì—†ë‹¤. ì´ëŸ°ì €ëŸ° í”„ë¡œê·¸ë¨ì—ì„œ ì—¬ëŸ¬ í”„ë¡œì‹œì €ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ì‹ì´ ë¹„ìŠ·í•œ ê²½ìš°ë¥¼ ì¢…ì¢… ë³¼ ìˆ˜ ìˆë‹¤. ê·¸ë˜ì„œ ë°˜ë³µí•˜ëŠ” ê³„ì‚° ë°©ì‹ì„ ê°„ì¶”ë¦¬ë ¤ë©´, ìˆ«ìëŠ” ë¬¼ë¡  ë‹¤ë¥¸ í”„ë¡œì‹œì €ë¥¼ ì¸ìë¡œ ë°›ê±°ë‚˜ ê²°ê³¼ë¡œ ë˜ëŒë ¤ ì£¼ëŠ” í”„ë¡œì‹œì €ë¥¼ ë§Œë“¤ ìˆ˜ ìˆì–´ì•¼ í•œë‹¤. ì´ì²˜ëŸ¼ í”„ë¡œì‹œì €ë¥¼ ë°ì´í„°ì²˜ëŸ¼ ì‚¬ìš©í•˜ëŠ” í”„ë¡œì‹œì €ë¥¼ ê³ ì°¨ í”„ë¡œì‹œì €( ë˜ëŠ” ê³ ì°¨ í•¨ìˆ˜) high-order function ë¼ê³  í•œë‹¤. 

### 1.3.1 í”„ë¡œì‹œì €ë¥¼ ì¸ìë¡œ ë°›ëŠ” í”„ë¡œì‹œì €

ë‹¤ìŒ ë‘ í•¨ìˆ˜ëŠ” ê°ê° aë¶€í„° bê¹Œì§€ ì •ìˆ˜ì˜ í•©ì„ êµ¬í•˜ëŠ” í”„ë¡œì‹œì €ì™€ ì •í•´ì§„ ë„“ì´ ì† ì •ìˆ˜ë¥¼ ì„¸ì œê³± í•˜ëŠ” í”„ë¡œì‹œì €ë‹¤. 

```swift
func sum_intergers(a: Int, b: Int) -> Int {
    if a > b {
        return 0
    }
    else {
        return a + sum_intergers(a + 1, b)
    }
}

func sum_cubes(a: Int, b: Int) -> Int {
    if a > b {
        return 0
    }
    else {
        return a + sum_cubes(a + 1, b)
    }
}
```

ì„¸ ë²ˆì§¸ í”„ë¡œì‹œì €ëŠ” ë‹¤ìŒ ìˆ˜ì—´ì—ì„œ ëª¨ë“  ë§ˆë””ë¥¼ ë”í•˜ëŠ” í”„ë¡œì‹œì €ë‹¤. 

```swift
func pi_sum(a: Double, b: Double) -> Double {
    if a > b {
        return 0
    }
    else {
        return 1.0 / (a * (a + 2)) + pi_sum(a + 4, b)
    }
}
```

ì—¬ê¸°ê¹Œì§€ í”„ë¡œì‹œì €ë¥¼ ì½ê³ ë‚˜ë©´ ì„¸ í”„ë¡œì‹œìê°€ ê°™ì€ ê³„ì‚° ë°©ë²•ì„ ì‚¬ìš©í•˜ê³  ìˆë‹¤ëŠ” ê²ƒì„ ëˆˆì¹˜ì±Œ ìˆ˜ ìˆë‹¤. í”„ë¡œì‹œì €ì˜ ì´ë¦„, ë§ˆë”” ê°’ aë¥¼ ë°›ì•„ì„œ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜, a ë‹¤ìŒ ê°’ì„ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜ë§Œ ë‹¤ë¥¼ ë¿ì´ë‹¤. ë”°ë¼ì„œ ë‹¤ìŒ í”„ë¡œì‹œì € í‹€ì—ì„œ name, term, next ë¹ˆ ì¹¸ë§Œ ì±„ìš°ë©´ ì„¸ ê°€ì§€ ëª¨ë“  í”„ë¡œì‹œì €ë¥¼ í‘œí˜„í•  ìˆ˜ ìˆë‹¤. 

```swift
func name(a: Double, b: Double) -> Double {
    if a > b {
        return 0
    }
    else {
        return term(a) + name(next(a), b)
    }
}
```

ì´ë ‡ê²Œ ì—¬ëŸ¬ í”„ë¡œì‹œì €ì— ê°™ì€ ê³„ì‚° ë°©ë²•ì„ ì ìš©í•  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì€ ì´ë¥¼ ê°„ì¶”ë¦´ ë•Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” í”„ë¡œì‹œì €ê°€ ë‚˜ì˜¬ ìˆ˜ ìˆë‹¤ëŠ” ì˜ë¯¸ë‹¤. ìˆ˜í•™ìë“¤ì€ ì•„ì£¼ ì˜¤ë˜ ì „ë¶€í„° ìˆ˜ì—´ ë§ˆë””ë¥¼ ë”í•˜ëŠ” ì¼ì„ ê°™ì€ ê³„ì‚° ë°©ë²•ìœ¼ë¡œ í‘œí˜„í•  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ì•Œì•˜ë‹¤. ê·¸ë ‡ê²Œ `ì‹œê·¸ë§ˆ í‘œí˜„ì‹`ì„ ë§Œë“¤ì—ˆë‹¤. 

name, term, next ë¹ˆ ìë¦¬ë¥¼ ì¸ì ì´ë¦„ì˜¤ ë°”ê¿”ì„œ í‘œí˜„í•´ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤. 

```swift
func sum(_ term: (Double) -> Double, _ a: Double, _ next: (Double) -> Double, _ b: Double) -> Double {
    if a > b {
        return 0
    }
    else {
        return term(a) + sum(term, next(a), next, b)
    }
} 
```

ìœ„ì— ì„ ì–¸í•œ sum í”„ë¡œì‹œì €ëŠ” ìˆ˜ì˜ ë²”ìœ„ë¥¼ ë‚˜íƒ€ë‚´ëŠ” a, b ë¿ë§Œ ì•„ë‹ˆë¼ í”„ë¡œì‹œì €ë¥¼ ì¸ìë¡œ ë°›ëŠ” termê³¼ nextê°€ ìˆë‹¤ëŠ” ê²ƒì„ ì£¼ì˜í•´ì•¼ í•œë‹¤. sumì„ ì‚¬ìš©í•˜ëŠ” ë°©ì‹ì€ ë³´í†µ í”„ë¡œì‹œì €ì™€ ë™ì¼í•˜ë‹¤. 

ì¸ìì— 1ì„ ë”í•˜ëŠ” í”„ë¡œì‹œì € inc()ì™€ sum_cubesë¥¼ ì •ì˜í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤. 

```swift
func inc(_ n: Double) -> Double {
    return n + 1
}

func sum_cubes(_ a: Double, _ b: Double) -> Double {
    return sum(cube, a, inc, b)
}

sum_cubes(1, 10)
```

ë˜ ë‹¤ë¥¸ ì˜ˆì œë¥¼ ì‚´í´ë³´ì. ë°›ì€ ëŒ€ë¡œ ê·¸ëŒ€ë¡œ ëŒë ¤ì£¼ëŠ” í•¨ìˆ˜ë¡œ identityê°€ ì •ì˜ë˜ì–´ ìˆë‹¤ë©´, í”„ë¡œì‹œì € sumìœ¼ë¡œ sum_integersë¥¼ ë§Œë“¤ì–´ë³´ì.

```swift
func identity(_ x: Double) -> Double {
    return x
}

func sum_integers(_ a: Double, _ b: Double) -> Double {
    return sum(identity, a, inc, b)
}

sum_integers(1, 10)
```

ìœ„ì—ì„œ êµ¬í˜„í–ˆë˜ pi_sum() í”„ë¡œì‹œì €ë¥¼ ë‹¤ì‹œ í•œ ë²ˆ ì„ ì–¸í•´ë³´ì.

```swift
func pi_sum(_ a: Double, _ b: Double) -> Double {
    func pi_term(_ x: Double) -> Double {
        return 1.0 / (x * (x + 2))
    }
    func pi_next(_ x: Double) -> Double {
        return x + 4
    }
    return sum(pi_term, a, pi_next, b)
}

8 * pi_sum(1, 1000)
```

í›¨ì”¬ ë³µì¡í•œ ì•„ì£¼ ì‘ì€ ê°’ dxê°€ ìˆì„ ë•Œ í•¨ìˆ˜ fë¥¼ aë¶€í„° ì‚¬ì´ì—ì„œ ì ë¶„í•œ ê°’ì€ ë‹¤ìŒê³¼ ê°™ë‹¤. 

```swift
func integral(_ f : (Double) -> Double, _ a: Double, _ b: Double, _ dx: Double) -> Double {
    func add_dx(_ x: Double) -> Double {
        return x + dx
    }
    return sum(f, a + dx / 2, add_dx, b) * dx
}

integral(cube, 0, 1, 0.01)
integral(cube, 0, 1, 0.005)
```

##### ì—°ìŠµë¬¸ì œ 1.29

```swift
func simpsons_rule_integral(f: (Double) -> Double, a: Double, b: Double, n: Double) -> Double {
    func helper(h: Double) -> Double {
        func y(_ k: Double) -> Double {
            return f((k*h) + a)
        }
        func term(k: Double) -> Double {
            if k == 0 || k == n {
                return y(k)
            }
            else if k.remainder(dividingBy: 2) == 0 {
                return 2 * y(k)
            }
            else {
                return 4 * y(k)
            }
        }
        return sum(term, 0, inc, n)
    }
    return helper(h: (b-a) / n )
}

simpsons_rule_integral(f: cube, a: 0, b: 1, n: 100)
simpsons_rule_integral(f: cube, a: 0, b: 1, n: 1000)
```

##### ì—°ìŠµë¬¸ì œ 1.30

```swift
func sum(term: (Double) -> Double, a: Double, next: (Double) -> Double, b: Double) -> Double {
    func iter(a: Double, result: Double) -> Double {
        if a > b {
            return result
        }
        else {
            return iter(a: next(a), result: result+term(a))
        }
    }
    return iter(a: a, result: 0)
}
```

##### ì—°ìŠµë¬¸ì œ 1.31

```swift
func product_r(term: (Double) -> Double, a: Double, next: (Double) -> Double, b: Double) -> Double { 
    if a > b {
        return 1
    }
    else {
        return term(a) * product_r(term: term, a: next(a), next: next, b: b)
    }
}

func product_i(term: (Double) -> Double, a: Double, next: (Double) -> Double, b: Double) -> Double { 
    func iter(_ a: Double, _ result : Double) -> Double {
        if a > b {
            return result
        }
        else {
            return iter(next(a), term(a) * result)
        }
    }
    return iter(a, 1)
}

product_r(term: identity, a:1, next:inc, b:5)
product_i(term: identity, a:1, next:inc, b:5)
```

##### ì—°ìŠµë¬¸ì œ 1.32

> ì¬ê·€ ë°©ì‹ 

```swift
func accumulate_r(combiner: (Double, Double) -> Double, null_value: Double, term: (Double) -> Double, a: Double, next: (Double) -> Double, b: Double) -> Double 
{
    if a > b {
        return null_value
    }
    else {
        return combiner(term(a), accumulate_r(combiner: combiner, null_value: null_value, 
                                              term: term, a: next(a), next: next, b: b))
    }
}
```

> ë°˜ë³µ ë°©ì‹

```swift
func accumulate_i(combiner: (Double, Double) -> Double, null_value: Double, term: (Double) -> Double, a: Double, next: (Double) -> Double, b: Double) -> Double 
{
    func iter(_ a: Double, _ result: Double) -> Double {
        if a > b {
            return result
        }
        else {
            return iter(next(a), combiner(term(a), result))
        }
    }
    return iter(a, null_value)
}

func sum_i(term: (Double) -> Double, a: Double, next: (Double) -> Double, b: Double) -> Double 
{
    func plus(_ x: Double, _ y: Double) -> Double {
        return x + y
    }
    return accumulate_i(combiner: plus, null_value: 0, term: term, a: a, next: next, b: b)
}

func product_r(term: (Double) -> Double, a: Double, next: (Double) -> Double, b: Double) -> Double {
    func times(_ x: Double, _ y: Double) -> Double {
        return x * y
    }
    return accumulate_i(combiner: times, null_value: 1, term: term, a: a, next: next, b: b)
}
```

##### ì—°ìŠµë¬¸ì œ 1.33

```swift
func filtered_accumulate(combiner: (Double, Double) -> Double, null_value: Double, term: (Double) -> Double, a: Double, next: (Double) -> Double, b: Double, filter: (Double) -> Bool) -> Double {
    if a > b {
        return null_value
    }
    else if filter(a){
        return combiner(term(a), filtered_accumulate(combiner: combiner, null_value: null_value, term: term, a: next(a), next: next, b: b, filter: filter))
    }
    else {
        return filtered_accumulate(combiner: combiner, null_value: null_value, term: term, a: next(a), next: next, b: b, filter: filter)
    }
}
```

## 1.3.2 í´ë¡œì €closureë¡œ ë‚˜íƒ€ë‚´ëŠ” í”„ë¡œì‹œì €

1.3.1ì ˆì—ì„œ sum()ì„ ë§Œë“¤ ë•Œì²˜ëŸ¼ pi_term() ì´ë‚˜ pi_next() ê°™ì€ í”„ë¡œì‹œì €ë¥¼ ì¸ìë¡œ ì „ë‹¬í•˜ê¸° ìœ„í•´ì„œ ë§¤ë²ˆ ì„ ì–¸í•˜ëŠ” ê²ƒì€ ê·€ì°®ì€ ì¼ì´ë‹¤. ê·¸ë˜ì„œ í•­ìƒ í”„ë¡œì‹œì €ë¥¼ ì„ ì–¸í•˜ëŠ” ëŒ€ì‹  'ì¸ìì— 4ë¥¼ ë”í•˜ê³  ëŒë ¤ì£¼ëŠ” í”„ë¡œì‹œì €' ë˜ëŠ” 'ì¸ìì™€ ì¸ìì— 2ë¥¼ ë”í•œ ê°’ì„ ê³±í•´ì„œ ì—­ìˆ˜ë¥¼ ê³„ì‚°í•˜ëŠ” í”„ë¡œì‹œì €'ë¥¼ ë°”ë¡œ ì„ ì–¸í•˜ëŠ” ê²Œ í¸ë¦¬í•˜ë‹¤. í´ë¡œì €ë¼ëŠ” í˜•ì‹ì´ ì´ëŸ° ë¬¸ì œë¥¼ í‘¸ëŠ” ë° ë„ì›€ì´ ëœë‹¤. 

ìŠ¤ìœ„í”„íŠ¸ì—ì„œ í´ë¡œì €ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì„ ì–¸í•œë‹¤. ê·¸ë ‡ì§€ë§Œ í´ë¡œì €ë¥¼ ì–´ë”˜ê°€ì— ë‹´ì§€ ì•ŠëŠ”ë‹¤ë©´ ì´ ìƒíƒœ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ì§€ëŠ” ëª»í•œë‹¤.

```swift
{ x in x + 4 }
{ x in 1 / (x * (x + 2)) }
```

í´ë¡œì €ë¥¼ ë‹¤ìŒê³¼ ê°™ì´ ìƒìˆ˜ì™€ í•¨ê»˜ ì„ ì–¸í•  ìˆ˜ ìˆë‹¤.
```swift
let k = { x in x + 4 }
let z = { x in 1 / (x * (x + 2)) }
```

ë˜ëŠ” integral() ê°™ì€ ë‹¤ë¥¸ í•¨ìˆ˜ë¥¼ ì„ ì–¸í•  ë•Œ ë³´ì¡° í•¨ìˆ˜ë¥¼ ì„ ì–¸í•˜ì§€ ì•Šê³  ì§ì ‘ ì„ ì–¸í•  ìˆ˜ ìˆë‹¤. 
```swift
func pi_sum(a: Double, b: Double) -> Double {
    return sum({x in 1 / (x * (x + 2))}, 
               a, 
               {x in x + 4},
               b
    )
}

func integral(_ f : (Double) -> Double, _ a: Double, _ b: Double, _ dx: Double) -> Double {
    return sum(f, a + dx / 2, { x in x + dx }, b) * dx
}
```

ì´ì²˜ëŸ¼ í•¨ìˆ˜ë¥¼ ì„ ì–¸í•˜ëŠ” ê²ƒê³¼ í° ì°¨ì´ëŠ” ì—†ì§€ë§Œ, ì´ë¦„ì„ ë¶™ì´ì§€ ì•Šê³  ë§¤ê°œ ë³€ìˆ˜ ìë¦¬ì— ë°”ë¡œ ë„£ì„ ìˆ˜ ìˆë‹¤. 

`func plus4(x: Double) -> Double { return x + 4 }`ë¡œ ì„ ì–¸í•œ í•¨ìˆ˜ê°€ ìˆë‹¤ê³  ê°€ì •í•˜ì. 
ì´ í”„ë¡œì‹œì €ëŠ” `let plus4 = { x in x + 4 }`ì²˜ëŸ¼ í´ë¡œì €ë¥¼ ìƒìˆ˜ì— ì„ ì–¸í•œ ê²ƒê³¼ ê°™ë‹¤. 

í´ë¡œì € ë¬¸ë²• ë‚´ìš©ì„ í’€ì–´ì„œ ì„¤ëª…í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤. 

![lambda]()

í•¨ìˆ˜ ëŒ€ì‹  ê°’ì„ ì²˜ë¦¬í•˜ëŠ” ì—°ì‚°ìê°€ ìˆëŠ” í‘œí˜„ì‹ì²˜ëŸ¼, ì—°ì‚°ì ëŒ€ì‹  í´ë¡œì €ë¥¼ ì„ ì–¸í•  ìˆ˜ë„ ìˆë‹¤. 

`let k = {(x, y, z) in x + y + square(z)}(1,2,3)` 

#### letìœ¼ë¡œ ê°‡íŒ ë³€ìˆ˜ ë§Œë“¤ê¸°

```swift
func f(x: Double, y: Double) -> Double {
    func f_helper(_ a: Double, _ b: Double) -> Double {
        return x * square(a) + y*b + a*b
    }
    return f_helper(1 + x*y, 1-y)
}
```

```swift
func f_closure(x: Double, y: Double) -> Double {
    return { a, b in x * square(a) + y*b + a*b }(1 + x*y, 1-y)
}
```

```swift
func f_local(x: Double, y: Double) -> Double {
    let a = 1 + x*y
    let b = 1 - y
    return x * square(a) + y*b + a*b
}
```

##### ì—°ìŠµë¬¸ì œ 1.34

```swift
func f(g: (Double) -> Double) -> Double {
    return g(2)
}

f(g: square)
> 4
f(g: { z in z * (z + 1)})
> 6
```

ìœ„ì— ì½”ë“œë¥¼ ì‹¤í–‰ì´ ë˜ì§€ë§Œ, `f(g: f)` í˜•ì‹ì€ ë™ì‘í•˜ì§€ ì•ŠëŠ”ë‹¤. ìŠ¤ìœ„í”„íŠ¸ëŠ” f() íƒ€ì…ì´ g() íƒ€ì…ê³¼ ë‹¤ë¥´ê¸° ë•Œë¬¸ì— ì»´íŒŒì¼ ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤.


## 1.3.3 ì¼ë°˜ ë°©ë²•ì„ í‘œí˜„í•˜ëŠ” í”„ë¡œì‹œì €

1.1.4ì ˆì—ì„œëŠ” ê³„ì‚°í•˜ëŠ” ë°©ë²•ì—ë§Œ ì§‘ì¤‘í•´ì„œ í”„ë¡œì‹œì €ë¡œ ìš”ì•½í•˜ëŠ” ë°©ë²•ì„ ë‹¤ë£¨ì—ˆë‹¤. 1.3.1ì ˆì—ì„œëŠ” ë§Œë“  integral ì ë¶„ ê³„ì‚°ì‹ì²˜ëŸ¼ ì°¨ìˆ˜ ë†’ì€ í”„ë¡œì‹œì €ë¥¼ ë§Œë“¤ì–´ì„œ ì“°ì„ìƒˆë¥¼ ëŠ˜ë¦´ ìˆ˜ ìˆì—ˆë‹¤.

#### ì´ë¶„ë²•ìœ¼ë¡œ ë°©ì •ì‹ì˜ ê·¼ ì°¾ê¸°
ì´ë¶„ë²• half-interval methodëŠ” ì–´ë–¤ ë„ˆë¹„ë¥¼ ë°˜ìœ¼ë¡œ ë‚˜ëˆ„ëŠ” ë°©ë²•ìœ¼ë¡œ, ì—°ì† í•¨ìˆ˜ fì—ì„œ f(x)=0ì„ ë§Œì¡±í•˜ëŠ” ê·¼ì„ ì°¾ëŠ” ë°©ë²•ì´ë‹¤. ê³„ì‚°ì„ ë°˜ë³µí•  ë•Œë§ˆë‹¤ ê°’ì„ ì°¾ì•„ì•¼ í•  ë„“ì´ê°€ ì ˆë°˜ìœ¼ë¡œ ì¤„ì–´ë“ ë‹¤. Lì´ ì²˜ìŒ ë„“ì´, Tê°€ í—ˆìš©ì˜¤ì°¨ error toleranceì¼ ë•Œ ê³„ì‚° ë‹¨ê³„ëŠ” ğœ£(log(L / T)) ì •ë„ê°€ ëœë‹¤. 

```swift
func search(_ f: (Double)-> Double, _ neg_point: Double, _ pos_point: Double) -> Double {
    let midpoint = average(neg_point, pos_point)
    if close_enough(neg_point, pos_point) {
        return midpoint
    }
    let test_value = f(midpoint)
    if positive(test_value) {
        return search(f, neg_point, midpoint)
    }
    else if negative(test_value) {
        return search(f, midpoint, pos_point)
    }
    return midpoint
}

func close_enough(_ x: Double, _ y: Double) -> Bool {
    return abs(x - y) < 0.001
}

func average(_ x: Double, _ y: Double) -> Double {
    return (x + y) / 2.0
}

func positive(_ x: Double) -> Bool {
    return x > 0
}

func negative(_ x: Double) -> Bool {
    return x < 0
}

func half_interval_method(_ f:(Double)->Double, _ a: Double, _ b: Double) -> Double? {
    let a_value = f(a)
    let b_value = f(b)
    if negative(a_value) && positive(b_value) {
        return search(f, a, b)
    }
    else if negative(b_value) && positive(a_value) {
        return search(f, b, a)
    }
    print("Values are not of opposite sign \(a), \(b)")
    return nil
}

print(half_interval_method(sin, 2.0, 4.0))
print(half_interval_method({ (x:Double) in (x*x*x) - (2*x) - 3 }, 1.0, 2.0))
```


#### ê³ ì •ì  ì°¾ê¸° í•¨ìˆ˜

íŠ¹ì •í•œ ìˆ˜ xì— ëŒ€í•´ f(x) = xê°€ ì°¸ì´ë©´ xë¥¼ fì˜ ê³ ì •ì  fixed pointë¼ê³  í•œë‹¤. 
í•¨ìˆ˜ fì— ì„ì‹œê°’ì„ ì£¼ê³  ë°˜ë³µí•´ì„œ fë¥¼ ê³„ì‚°í•˜ë‹¤ê°€ ê·¸ ê°’ì´ í¬ê²Œ ë°”ë€Œì§€ ì•Šìœ¼ë©´ fì˜ ê³ ì •ì ì„ ì°¾ì„ ìˆ˜ ìˆë‹¤. 

```swift
let tolerance = 0.0001
func fixed_point(_ f:(Double)->Double, _ first_guess:Double) -> Double {
    func close_enough(_ x: Double, _ y: Double) -> Bool {
        return abs(x - y) < tolerance
    }
    func try_with(guess: Double) -> Double {
        let next = f(guess)
        if close_enough(guess, next) {
            return next
        }
        else {
            return try_with(guess: next)
        }
    }
    return try_with(guess: first_guess)
}

fixed_point(cos, 1.0)
fixed_point( { y in sin(y) + cos(y)} , 1.0)
```

1.1.7ì ˆì—ì„œ ì œê³±ê·¼ì„ ì°¾ë˜ ë°©ë²•ì„ ê³ ì •ì  ì°¾ëŠ” ë°©ì‹ìœ¼ë¡œ í‘œí˜„í•˜ë©´ `y = x / y` ê°€ ë˜ëŠ” ê³ ì •ì ì„ ì°¾ìœ¼ë©´ ëœë‹¤. 

```swift
func sqrt_y(x: Double) -> Double {
    return fixed_point({ y in x / y}, 1.0)
}
```

í•˜ì§€ë§Œ ì´ë ‡ê²Œ êµ¬í˜„í•˜ë©´ ì œê¸‰ê·¼ì— ê°€ê¹Œì›Œì§€ì§€ ì•Šê³ , ê³ ì •ì  ê·¼ì²˜ë¥¼ ì™”ë‹¤ê°”ë‹¤ ë°˜ë³µí•  ë¿ì´ë‹¤. 
y ë‹¤ìŒ ê°’ì´ x/y ëŒ€ì‹  `(y + x/y)/2` ê°€ ë˜ë„ë¡ yì™€ x/y í‰ê· ê°’ì„ êµ¬í•˜ë©´ ëœë‹¤. 

```swift
func sqrt(x: Double) -> Double {
    return fixed_point({ y in average(y, (x / y))}, 1.0)
}
```


##### ì—°ìŠµë¬¸ì œ 1.35

`fixed_point( { x in 1 + (1 / x)}, 1.0 )`

##### ì—°ìŠµë¬¸ì œ 1.36

> ì¶œë ¥í•˜ëŠ” ë²„ì „ê³¼ í‰ê· ê°’ìœ¼ë¡œ ì°¾ì•„ê°€ëŠ” ë²„ì „

```swift
let tolerance = 0.0001
func fixed_point(_ f:(Double)->Double, _ first_guess:Double) -> Double {
    func close_enough(_ x: Double, _ y: Double) -> Bool {
        return abs(x - y) < tolerance
    }
    func try_with(guess: Double) -> Double {
        print("guess = \(guess)")
        let next = f(guess)
        if close_enough(guess, next) {
            return next
        }
        else {
            return try_with(guess: next)
        }
    }
    return try_with(guess: first_guess)
}

func fixed_point_average(_ f:(Double)->Double, _ first_guess:Double) -> Double {
    func close_enough(_ x: Double, _ y: Double) -> Bool {
        return abs(x - y) < tolerance
    }
    func try_with(guess: Double) -> Double {
        print("guess = \(guess)")
        let next = (guess + f(guess)) / 2
        if close_enough(guess, next) {
            return next
        }
        else {
            return try_with(guess: next)
        }
    }
    return try_with(guess: first_guess)
}
```

##### ì—°ìŠµë¬¸ì œ 1.37

> ë°˜ë³µ í”„ë¡œì‹œì €

```swift
func continue_frac_r(n: (Double)->Double, d: (Double)->Double, k: Double) -> Double {
    func fraction(i: Double) -> Double {
        if i > k {
            return 0
        }
        return n(i) / (d(i) + fraction(i: i+1))
    }
    return fraction(i: 1)
}

continue_frac_r(n: { i in 1.0 }, d: { i in 1.0 }, k: 20)
```

> ì ˆì°¨ í”„ë¡œì‹œì €

```swift
func continue_frac_i(n: (Double)->Double, d: (Double)->Double, k: Double) -> Double {
    func fraction(_ i: Double, _ current: Double) -> Double {
        if i == 0 {
            return current
        }
        return fraction(i - 1, n(i) / (d(i) + current))
    }
    return fraction(k, 0)
}

continue_frac_i(n: { i in 1.0 }, d: { i in 1.0 }, k: 20)
```

##### ì—°ìŠµë¬¸ì œ 1.38

```swift
print(2 + continue_frac_r(n: { i in 1.0 }, 
                    d: { i in ((i + 1).remainder(dividingBy: 3) < 1) ? 2 * (i+1) / 3 : 1.0}, 
                    k: 20))
```

##### ì—°ìŠµë¬¸ì œ 1.39

```swift
func tan_cf(x: Double, k: Double) -> Double {
    return continue_frac_i(n: { i in i == 1 ? x : -x * x }, 
                            d: { i in 2 * i - 1}, k: k)
}

print(tan_cf(x: 3.14 / 2.0, k: 20))
```

## 1.3.4 í”„ë¡œì‹œì €ë¥¼ ë§Œë“œëŠ” í”„ë¡œì‹œì € Procedures as Returned Values

